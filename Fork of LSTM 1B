{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "6683a129",
   "metadata": {
    "papermill": {
     "duration": 0.004827,
     "end_time": "2025-09-15T06:25:53.960991",
     "exception": false,
     "start_time": "2025-09-15T06:25:53.956164",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "# Gold Price Prediction with LSTM\n",
    "- Skenario 1B: Menggunakan harga emas historis + nilai tukar (USD/IDR)."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "ea141c64",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2025-09-15T06:25:53.970522Z",
     "iopub.status.busy": "2025-09-15T06:25:53.970196Z",
     "iopub.status.idle": "2025-09-15T06:25:56.068310Z",
     "shell.execute_reply": "2025-09-15T06:25:56.067162Z"
    },
    "papermill": {
     "duration": 2.104727,
     "end_time": "2025-09-15T06:25:56.069981",
     "exception": false,
     "start_time": "2025-09-15T06:25:53.965254",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "/kaggle/input/datasethargaemasindikatormoneter/Final Dataset Gold Prediction.csv\n",
      "/kaggle/input/datasethargaemasindikatormoneter/Data Gabungan Lengkap.csv\n",
      "/kaggle/input/datasethargaemasindikatormoneter/Dataset Harga Emas dan Indikator Moneter.csv\n"
     ]
    }
   ],
   "source": [
    "# This Python 3 environment comes with many helpful analytics libraries installed\n",
    "# It is defined by the kaggle/python Docker image: https://github.com/kaggle/docker-python\n",
    "# For example, here's several helpful packages to load\n",
    "\n",
    "import numpy as np # linear algebra\n",
    "import pandas as pd # data processing, CSV file I/O (e.g. pd.read_csv)\n",
    "\n",
    "# Input data files are available in the read-only \"../input/\" directory\n",
    "# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n",
    "\n",
    "import os\n",
    "for dirname, _, filenames in os.walk('/kaggle/input'):\n",
    "    for filename in filenames:\n",
    "        print(os.path.join(dirname, filename))\n",
    "\n",
    "# You can write up to 20GB to the current directory (/kaggle/working/) that gets preserved as output when you create a version using \"Save & Run All\" \n",
    "# You can also write temporary files to /kaggle/temp/, but they won't be saved outside of the current session"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "bf4ad520",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2025-09-15T06:25:56.080139Z",
     "iopub.status.busy": "2025-09-15T06:25:56.079730Z",
     "iopub.status.idle": "2025-09-15T06:26:15.705917Z",
     "shell.execute_reply": "2025-09-15T06:26:15.704719Z"
    },
    "papermill": {
     "duration": 19.633982,
     "end_time": "2025-09-15T06:26:15.708569",
     "exception": false,
     "start_time": "2025-09-15T06:25:56.074587",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "2025-09-15 06:25:59.756978: E external/local_xla/xla/stream_executor/cuda/cuda_fft.cc:477] Unable to register cuFFT factory: Attempting to register factory for plugin cuFFT when one has already been registered\n",
      "WARNING: All log messages before absl::InitializeLog() is called are written to STDERR\n",
      "E0000 00:00:1757917560.008477      13 cuda_dnn.cc:8310] Unable to register cuDNN factory: Attempting to register factory for plugin cuDNN when one has already been registered\n",
      "E0000 00:00:1757917560.078790      13 cuda_blas.cc:1418] Unable to register cuBLAS factory: Attempting to register factory for plugin cuBLAS when one has already been registered\n"
     ]
    }
   ],
   "source": [
    "# Import Libraries\n",
    "import numpy as np\n",
    "import pandas as pd\n",
    "\n",
    "import matplotlib.pyplot as plt\n",
    "import matplotlib.dates as mdates\n",
    "\n",
    "from sklearn.metrics import mean_squared_log_error\n",
    "from sklearn.preprocessing import MinMaxScaler\n",
    "from sklearn.metrics import mean_squared_error, mean_absolute_percentage_error, r2_score\n",
    "\n",
    "from tensorflow.keras.models import Sequential\n",
    "from tensorflow.keras.layers import Input, LSTM, Dense, Dropout\n",
    "from tensorflow.keras.callbacks import EarlyStopping\n",
    "from tensorflow.keras.optimizers import Adam"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "e41d5359",
   "metadata": {
    "papermill": {
     "duration": 0.00413,
     "end_time": "2025-09-15T06:26:15.717230",
     "exception": false,
     "start_time": "2025-09-15T06:26:15.713100",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "## Load Dataset"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "a60443c0",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2025-09-15T06:26:15.727265Z",
     "iopub.status.busy": "2025-09-15T06:26:15.726681Z",
     "iopub.status.idle": "2025-09-15T06:26:15.761491Z",
     "shell.execute_reply": "2025-09-15T06:26:15.760190Z"
    },
    "papermill": {
     "duration": 0.041635,
     "end_time": "2025-09-15T06:26:15.763157",
     "exception": false,
     "start_time": "2025-09-15T06:26:15.721522",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "       Date   Price  Exchange Rate  Foreign Exchange Reserves  Money Supply\n",
      "0  1/3/2017  606000          13485                      116.9    4936881.99\n",
      "1  1/4/2017  606000          13478                      116.9    4936881.99\n",
      "2  1/5/2017  607000          13370                      116.9    4936881.99\n",
      "3  1/6/2017  606000          13347                      116.9    4936881.99\n",
      "4  1/9/2017  602000          13385                      116.9    4936881.99\n"
     ]
    }
   ],
   "source": [
    "# Load dataset\n",
    "df = pd.read_csv(\"/kaggle/input/datasethargaemasindikatormoneter/Final Dataset Gold Prediction.csv\")  # Modify path if needed\n",
    "print(df.head()) "
   ]
  },
  {
   "cell_type": "markdown",
   "id": "e3658304",
   "metadata": {
    "papermill": {
     "duration": 0.003928,
     "end_time": "2025-09-15T06:26:15.771725",
     "exception": false,
     "start_time": "2025-09-15T06:26:15.767797",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "## Data Preprocessing with Indicators"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "c98c227e",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2025-09-15T06:26:15.781572Z",
     "iopub.status.busy": "2025-09-15T06:26:15.781178Z",
     "iopub.status.idle": "2025-09-15T06:26:15.805636Z",
     "shell.execute_reply": "2025-09-15T06:26:15.804312Z"
    },
    "papermill": {
     "duration": 0.03141,
     "end_time": "2025-09-15T06:26:15.807301",
     "exception": false,
     "start_time": "2025-09-15T06:26:15.775891",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "<class 'pandas.core.frame.DataFrame'>\n",
      "RangeIndex: 1932 entries, 0 to 1931\n",
      "Data columns (total 5 columns):\n",
      " #   Column                     Non-Null Count  Dtype  \n",
      "---  ------                     --------------  -----  \n",
      " 0   Date                       1932 non-null   object \n",
      " 1   Price                      1932 non-null   int64  \n",
      " 2   Exchange Rate              1932 non-null   int64  \n",
      " 3   Foreign Exchange Reserves  1932 non-null   float64\n",
      " 4   Money Supply               1932 non-null   float64\n",
      "dtypes: float64(2), int64(2), object(1)\n",
      "memory usage: 75.6+ KB\n"
     ]
    }
   ],
   "source": [
    "df.info()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "id": "0fc2d2e2",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2025-09-15T06:26:15.817385Z",
     "iopub.status.busy": "2025-09-15T06:26:15.817032Z",
     "iopub.status.idle": "2025-09-15T06:26:15.832345Z",
     "shell.execute_reply": "2025-09-15T06:26:15.831503Z"
    },
    "papermill": {
     "duration": 0.022329,
     "end_time": "2025-09-15T06:26:15.834093",
     "exception": false,
     "start_time": "2025-09-15T06:26:15.811764",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "df['Date'] = pd.to_datetime(df['Date'])\n",
    "df.sort_values(by='Date', ascending=True, inplace=True)\n",
    "df.reset_index(drop=True, inplace=True)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "id": "7e66018d",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2025-09-15T06:26:15.845471Z",
     "iopub.status.busy": "2025-09-15T06:26:15.845142Z",
     "iopub.status.idle": "2025-09-15T06:26:15.853568Z",
     "shell.execute_reply": "2025-09-15T06:26:15.852705Z"
    },
    "papermill": {
     "duration": 0.015816,
     "end_time": "2025-09-15T06:26:15.855275",
     "exception": false,
     "start_time": "2025-09-15T06:26:15.839459",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "0"
      ]
     },
     "execution_count": 6,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# Check duplicate\n",
    "df.duplicated().sum()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "id": "c377e4e4",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2025-09-15T06:26:15.866174Z",
     "iopub.status.busy": "2025-09-15T06:26:15.865828Z",
     "iopub.status.idle": "2025-09-15T06:26:15.873004Z",
     "shell.execute_reply": "2025-09-15T06:26:15.872076Z"
    },
    "papermill": {
     "duration": 0.014281,
     "end_time": "2025-09-15T06:26:15.874498",
     "exception": false,
     "start_time": "2025-09-15T06:26:15.860217",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "0"
      ]
     },
     "execution_count": 7,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# Check missing values\n",
    "df.isnull().sum().sum()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "id": "f0057df6",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2025-09-15T06:26:15.884699Z",
     "iopub.status.busy": "2025-09-15T06:26:15.884335Z",
     "iopub.status.idle": "2025-09-15T06:26:15.888759Z",
     "shell.execute_reply": "2025-09-15T06:26:15.887760Z"
    },
    "papermill": {
     "duration": 0.011231,
     "end_time": "2025-09-15T06:26:15.890315",
     "exception": false,
     "start_time": "2025-09-15T06:26:15.879084",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "# Features to use\n",
    "features = ['Price', 'Exchange Rate']\n",
    "\n",
    "# 'Inflasi', 'IndONIA', 'Cadangan Devisa', 'Money Supply (M2)'"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "id": "9229a19d",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2025-09-15T06:26:15.901252Z",
     "iopub.status.busy": "2025-09-15T06:26:15.900946Z",
     "iopub.status.idle": "2025-09-15T06:26:15.910037Z",
     "shell.execute_reply": "2025-09-15T06:26:15.909086Z"
    },
    "papermill": {
     "duration": 0.016344,
     "end_time": "2025-09-15T06:26:15.911711",
     "exception": false,
     "start_time": "2025-09-15T06:26:15.895367",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "# Scaling all features\n",
    "scaler = MinMaxScaler()\n",
    "scaled_features = scaler.fit_transform(df[features])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "id": "7a56a599",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2025-09-15T06:26:15.922166Z",
     "iopub.status.busy": "2025-09-15T06:26:15.921835Z",
     "iopub.status.idle": "2025-09-15T06:26:15.932474Z",
     "shell.execute_reply": "2025-09-15T06:26:15.931509Z"
    },
    "papermill": {
     "duration": 0.017702,
     "end_time": "2025-09-15T06:26:15.934061",
     "exception": false,
     "start_time": "2025-09-15T06:26:15.916359",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "# Creating the dataset with windowing\n",
    "window_size = 60\n",
    "X, y = [], []\n",
    "for i in range(window_size, len(scaled_features)):\n",
    "    X.append(scaled_features[i-window_size:i, :])  # All features\n",
    "    y.append(scaled_features[i, 0])  # Target: Price (index 0)\n",
    "\n",
    "X, y = np.array(X), np.array(y)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "id": "0cbfd4b0",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2025-09-15T06:26:15.944700Z",
     "iopub.status.busy": "2025-09-15T06:26:15.943957Z",
     "iopub.status.idle": "2025-09-15T06:26:15.949372Z",
     "shell.execute_reply": "2025-09-15T06:26:15.948464Z"
    },
    "papermill": {
     "duration": 0.0123,
     "end_time": "2025-09-15T06:26:15.950922",
     "exception": false,
     "start_time": "2025-09-15T06:26:15.938622",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "# Train-Validation-Test split (70:15:15)\n",
    "train_size = int(0.7 * len(X))\n",
    "val_size   = int(0.15 * len(X))\n",
    "\n",
    "X_train = X[:train_size]\n",
    "y_train = y[:train_size]\n",
    "\n",
    "X_val = X[train_size:train_size + val_size]\n",
    "y_val = y[train_size:train_size + val_size]\n",
    "\n",
    "X_test = X[train_size + val_size:]\n",
    "y_test = y[train_size + val_size:]\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "442b7f51",
   "metadata": {
    "papermill": {
     "duration": 0.004145,
     "end_time": "2025-09-15T06:26:15.959746",
     "exception": false,
     "start_time": "2025-09-15T06:26:15.955601",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "## Hyperparameter Tuning"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "id": "b73d1063",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2025-09-15T06:26:15.969505Z",
     "iopub.status.busy": "2025-09-15T06:26:15.969197Z",
     "iopub.status.idle": "2025-09-15T06:33:12.750194Z",
     "shell.execute_reply": "2025-09-15T06:33:12.749128Z"
    },
    "papermill": {
     "duration": 416.787819,
     "end_time": "2025-09-15T06:33:12.751921",
     "exception": false,
     "start_time": "2025-09-15T06:26:15.964102",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "2025-09-15 06:26:15.983656: E external/local_xla/xla/stream_executor/cuda/cuda_driver.cc:152] failed call to cuInit: INTERNAL: CUDA error: Failed call to cuInit: UNKNOWN ERROR (303)\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\u001b[1m9/9\u001b[0m \u001b[32m━━━━━━━━━━━━━━━━━━━━\u001b[0m\u001b[37m\u001b[0m \u001b[1m1s\u001b[0m 65ms/step\n",
      "Finished: units=32, dropout=0.2, lr=0.001, batch_size=32 | RMSE=87838.4000\n",
      "\u001b[1m9/9\u001b[0m \u001b[32m━━━━━━━━━━━━━━━━━━━━\u001b[0m\u001b[37m\u001b[0m \u001b[1m1s\u001b[0m 67ms/step\n",
      "Finished: units=32, dropout=0.2, lr=0.001, batch_size=64 | RMSE=82564.1978\n",
      "\u001b[1m9/9\u001b[0m \u001b[32m━━━━━━━━━━━━━━━━━━━━\u001b[0m\u001b[37m\u001b[0m \u001b[1m2s\u001b[0m 69ms/step\n",
      "Finished: units=32, dropout=0.2, lr=0.0005, batch_size=32 | RMSE=57352.7814\n",
      "\u001b[1m9/9\u001b[0m \u001b[32m━━━━━━━━━━━━━━━━━━━━\u001b[0m\u001b[37m\u001b[0m \u001b[1m1s\u001b[0m 68ms/step\n",
      "Finished: units=32, dropout=0.2, lr=0.0005, batch_size=64 | RMSE=30285.6518\n",
      "\u001b[1m9/9\u001b[0m \u001b[32m━━━━━━━━━━━━━━━━━━━━\u001b[0m\u001b[37m\u001b[0m \u001b[1m1s\u001b[0m 65ms/step\n",
      "Finished: units=32, dropout=0.3, lr=0.001, batch_size=32 | RMSE=63392.4949\n",
      "\u001b[1m9/9\u001b[0m \u001b[32m━━━━━━━━━━━━━━━━━━━━\u001b[0m\u001b[37m\u001b[0m \u001b[1m1s\u001b[0m 72ms/step\n",
      "Finished: units=32, dropout=0.3, lr=0.001, batch_size=64 | RMSE=37272.7787\n",
      "\u001b[1m9/9\u001b[0m \u001b[32m━━━━━━━━━━━━━━━━━━━━\u001b[0m\u001b[37m\u001b[0m \u001b[1m1s\u001b[0m 66ms/step\n",
      "Finished: units=32, dropout=0.3, lr=0.0005, batch_size=32 | RMSE=113616.6119\n",
      "\u001b[1m9/9\u001b[0m \u001b[32m━━━━━━━━━━━━━━━━━━━━\u001b[0m\u001b[37m\u001b[0m \u001b[1m2s\u001b[0m 166ms/step\n",
      "Finished: units=32, dropout=0.3, lr=0.0005, batch_size=64 | RMSE=50931.8794\n",
      "\u001b[1m9/9\u001b[0m \u001b[32m━━━━━━━━━━━━━━━━━━━━\u001b[0m\u001b[37m\u001b[0m \u001b[1m1s\u001b[0m 72ms/step\n",
      "Finished: units=64, dropout=0.2, lr=0.001, batch_size=32 | RMSE=68752.3924\n",
      "\u001b[1m9/9\u001b[0m \u001b[32m━━━━━━━━━━━━━━━━━━━━\u001b[0m\u001b[37m\u001b[0m \u001b[1m1s\u001b[0m 77ms/step\n",
      "Finished: units=64, dropout=0.2, lr=0.001, batch_size=64 | RMSE=57431.7141\n",
      "\u001b[1m9/9\u001b[0m \u001b[32m━━━━━━━━━━━━━━━━━━━━\u001b[0m\u001b[37m\u001b[0m \u001b[1m1s\u001b[0m 72ms/step\n",
      "Finished: units=64, dropout=0.2, lr=0.0005, batch_size=32 | RMSE=62235.2478\n",
      "\u001b[1m9/9\u001b[0m \u001b[32m━━━━━━━━━━━━━━━━━━━━\u001b[0m\u001b[37m\u001b[0m \u001b[1m1s\u001b[0m 72ms/step\n",
      "Finished: units=64, dropout=0.2, lr=0.0005, batch_size=64 | RMSE=26255.4284\n",
      "\u001b[1m9/9\u001b[0m \u001b[32m━━━━━━━━━━━━━━━━━━━━\u001b[0m\u001b[37m\u001b[0m \u001b[1m2s\u001b[0m 76ms/step\n",
      "Finished: units=64, dropout=0.3, lr=0.001, batch_size=32 | RMSE=76469.0881\n",
      "\u001b[1m9/9\u001b[0m \u001b[32m━━━━━━━━━━━━━━━━━━━━\u001b[0m\u001b[37m\u001b[0m \u001b[1m1s\u001b[0m 71ms/step\n",
      "Finished: units=64, dropout=0.3, lr=0.001, batch_size=64 | RMSE=30612.8520\n",
      "\u001b[1m9/9\u001b[0m \u001b[32m━━━━━━━━━━━━━━━━━━━━\u001b[0m\u001b[37m\u001b[0m \u001b[1m1s\u001b[0m 72ms/step\n",
      "Finished: units=64, dropout=0.3, lr=0.0005, batch_size=32 | RMSE=55890.9285\n",
      "\u001b[1m9/9\u001b[0m \u001b[32m━━━━━━━━━━━━━━━━━━━━\u001b[0m\u001b[37m\u001b[0m \u001b[1m1s\u001b[0m 70ms/step\n",
      "Finished: units=64, dropout=0.3, lr=0.0005, batch_size=64 | RMSE=31128.0383\n",
      "    units  dropout  learning_rate  batch_size          RMSE      MAPE  \\\n",
      "11     64      0.2         0.0005          64  26255.428390  0.015199   \n",
      "3      32      0.2         0.0005          64  30285.651781  0.019472   \n",
      "13     64      0.3         0.0010          64  30612.852003  0.017833   \n",
      "15     64      0.3         0.0005          64  31128.038350  0.018005   \n",
      "5      32      0.3         0.0010          64  37272.778731  0.021236   \n",
      "\n",
      "          R2  \n",
      "11  0.970264  \n",
      "3   0.960434  \n",
      "13  0.959575  \n",
      "15  0.958202  \n",
      "5   0.940072  \n"
     ]
    }
   ],
   "source": [
    "# Define grid\n",
    "units_list = [32, 64]\n",
    "dropout_list = [0.2, 0.3]\n",
    "learning_rate_list = [0.001, 0.0005]\n",
    "batch_size_list = [32, 64]\n",
    "\n",
    "results = []\n",
    "\n",
    "# Tuning\n",
    "# Tuning\n",
    "for units in units_list:\n",
    "    for dropout_rate in dropout_list:\n",
    "        for lr in learning_rate_list:\n",
    "            for batch_size in batch_size_list:\n",
    "                model = Sequential()\n",
    "                model.add(Input(shape=(X_train.shape[1], X_train.shape[2])))  # Tambahkan di sini\n",
    "                model.add(LSTM(units=units, return_sequences=True))\n",
    "                model.add(Dropout(dropout_rate))\n",
    "                model.add(LSTM(units=units//2, return_sequences=False))\n",
    "                model.add(Dropout(dropout_rate))\n",
    "                model.add(Dense(1))\n",
    "                \n",
    "                optimizer = Adam(learning_rate=lr)\n",
    "                model.compile(optimizer=optimizer, loss='mean_squared_error')\n",
    "                \n",
    "                early_stop = EarlyStopping(monitor='val_loss', patience=5, restore_best_weights=True)\n",
    "                \n",
    "                history = model.fit(X_train, y_train, epochs=30, batch_size=batch_size, \n",
    "                                    validation_data=(X_val, y_val), callbacks=[early_stop], verbose=0)\n",
    "                \n",
    "                y_pred = model.predict(X_test)\n",
    "                y_pred_inv = scaler.inverse_transform(np.concatenate((y_pred, np.zeros((y_pred.shape[0], scaled_features.shape[1]-1))), axis=1))[:,0]\n",
    "                y_test_inv = scaler.inverse_transform(np.concatenate((y_test.reshape(-1,1), np.zeros((y_test.shape[0], scaled_features.shape[1]-1))), axis=1))[:,0]\n",
    "                \n",
    "                rmse = np.sqrt(mean_squared_error(y_test_inv, y_pred_inv))\n",
    "                mape = mean_absolute_percentage_error(y_test_inv, y_pred_inv)\n",
    "                r2 = r2_score(y_test_inv, y_pred_inv)\n",
    "                \n",
    "                results.append({\n",
    "                    'units': units,\n",
    "                    'dropout': dropout_rate,\n",
    "                    'learning_rate': lr,\n",
    "                    'batch_size': batch_size,\n",
    "                    'RMSE': rmse,\n",
    "                    'MAPE': mape,\n",
    "                    'R2': r2\n",
    "                })\n",
    "                print(f\"Finished: units={units}, dropout={dropout_rate}, lr={lr}, batch_size={batch_size} | RMSE={rmse:.4f}\")\n",
    "\n",
    "results_df = pd.DataFrame(results)\n",
    "results_df = results_df.sort_values(by='RMSE')\n",
    "print(results_df.head(5))"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "d74e163b",
   "metadata": {
    "papermill": {
     "duration": 0.008018,
     "end_time": "2025-09-15T06:33:12.768932",
     "exception": false,
     "start_time": "2025-09-15T06:33:12.760914",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "## Retrain Final Model with Best Hyperparameters"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "id": "50862f23",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2025-09-15T06:33:12.786891Z",
     "iopub.status.busy": "2025-09-15T06:33:12.786535Z",
     "iopub.status.idle": "2025-09-15T06:33:45.294182Z",
     "shell.execute_reply": "2025-09-15T06:33:45.293269Z"
    },
    "papermill": {
     "duration": 32.518643,
     "end_time": "2025-09-15T06:33:45.295878",
     "exception": false,
     "start_time": "2025-09-15T06:33:12.777235",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Epoch 1/150\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "/usr/local/lib/python3.11/dist-packages/keras/src/layers/rnn/rnn.py:200: UserWarning: Do not pass an `input_shape`/`input_dim` argument to a layer. When using Sequential models, prefer using an `Input(shape)` object as the first layer in the model instead.\n",
      "  super().__init__(**kwargs)\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\u001b[1m41/41\u001b[0m \u001b[32m━━━━━━━━━━━━━━━━━━━━\u001b[0m\u001b[37m\u001b[0m \u001b[1m8s\u001b[0m 67ms/step - loss: 0.0189 - val_loss: 0.0019\n",
      "Epoch 2/150\n",
      "\u001b[1m41/41\u001b[0m \u001b[32m━━━━━━━━━━━━━━━━━━━━\u001b[0m\u001b[37m\u001b[0m \u001b[1m2s\u001b[0m 51ms/step - loss: 0.0014 - val_loss: 3.7700e-04\n",
      "Epoch 3/150\n",
      "\u001b[1m41/41\u001b[0m \u001b[32m━━━━━━━━━━━━━━━━━━━━\u001b[0m\u001b[37m\u001b[0m \u001b[1m2s\u001b[0m 49ms/step - loss: 0.0012 - val_loss: 2.5324e-04\n",
      "Epoch 4/150\n",
      "\u001b[1m41/41\u001b[0m \u001b[32m━━━━━━━━━━━━━━━━━━━━\u001b[0m\u001b[37m\u001b[0m \u001b[1m2s\u001b[0m 50ms/step - loss: 9.7315e-04 - val_loss: 8.1412e-04\n",
      "Epoch 5/150\n",
      "\u001b[1m41/41\u001b[0m \u001b[32m━━━━━━━━━━━━━━━━━━━━\u001b[0m\u001b[37m\u001b[0m \u001b[1m2s\u001b[0m 50ms/step - loss: 0.0010 - val_loss: 5.0633e-04\n",
      "Epoch 6/150\n",
      "\u001b[1m41/41\u001b[0m \u001b[32m━━━━━━━━━━━━━━━━━━━━\u001b[0m\u001b[37m\u001b[0m \u001b[1m2s\u001b[0m 49ms/step - loss: 9.6619e-04 - val_loss: 0.0012\n",
      "Epoch 7/150\n",
      "\u001b[1m41/41\u001b[0m \u001b[32m━━━━━━━━━━━━━━━━━━━━\u001b[0m\u001b[37m\u001b[0m \u001b[1m2s\u001b[0m 49ms/step - loss: 9.3185e-04 - val_loss: 7.3912e-04\n",
      "Epoch 8/150\n",
      "\u001b[1m41/41\u001b[0m \u001b[32m━━━━━━━━━━━━━━━━━━━━\u001b[0m\u001b[37m\u001b[0m \u001b[1m2s\u001b[0m 49ms/step - loss: 9.2300e-04 - val_loss: 3.2168e-04\n",
      "Epoch 9/150\n",
      "\u001b[1m41/41\u001b[0m \u001b[32m━━━━━━━━━━━━━━━━━━━━\u001b[0m\u001b[37m\u001b[0m \u001b[1m2s\u001b[0m 50ms/step - loss: 6.7933e-04 - val_loss: 2.7850e-04\n",
      "Epoch 10/150\n",
      "\u001b[1m41/41\u001b[0m \u001b[32m━━━━━━━━━━━━━━━━━━━━\u001b[0m\u001b[37m\u001b[0m \u001b[1m2s\u001b[0m 50ms/step - loss: 7.1152e-04 - val_loss: 3.0623e-04\n",
      "Epoch 11/150\n",
      "\u001b[1m41/41\u001b[0m \u001b[32m━━━━━━━━━━━━━━━━━━━━\u001b[0m\u001b[37m\u001b[0m \u001b[1m2s\u001b[0m 52ms/step - loss: 9.0940e-04 - val_loss: 6.4929e-04\n",
      "Epoch 12/150\n",
      "\u001b[1m41/41\u001b[0m \u001b[32m━━━━━━━━━━━━━━━━━━━━\u001b[0m\u001b[37m\u001b[0m \u001b[1m2s\u001b[0m 50ms/step - loss: 7.0268e-04 - val_loss: 3.0365e-04\n",
      "Epoch 13/150\n",
      "\u001b[1m41/41\u001b[0m \u001b[32m━━━━━━━━━━━━━━━━━━━━\u001b[0m\u001b[37m\u001b[0m \u001b[1m2s\u001b[0m 47ms/step - loss: 7.2940e-04 - val_loss: 2.6575e-04\n"
     ]
    }
   ],
   "source": [
    "# Based on tuning result\n",
    "best_units = 64\n",
    "best_dropout = 0.2\n",
    "best_lr = 0.001\n",
    "best_batch_size = 32\n",
    "\n",
    "final_model = Sequential()\n",
    "final_model.add(LSTM(units=best_units, return_sequences=True, input_shape=(X_train.shape[1], X_train.shape[2])))\n",
    "final_model.add(Dropout(best_dropout))\n",
    "final_model.add(LSTM(units=best_units//2, return_sequences=False))\n",
    "final_model.add(Dropout(best_dropout))\n",
    "final_model.add(Dense(1))\n",
    "\n",
    "optimizer = Adam(learning_rate=best_lr)\n",
    "final_model.compile(optimizer=optimizer, loss='mean_squared_error')\n",
    "\n",
    "early_stop = EarlyStopping(monitor='val_loss', patience=10, restore_best_weights=True)\n",
    "\n",
    "history_final = final_model.fit(\n",
    "    X_train, y_train,\n",
    "    epochs=150,\n",
    "    batch_size=best_batch_size,\n",
    "    validation_data=(X_val, y_val),\n",
    "    callbacks=[early_stop],\n",
    "    verbose=1\n",
    ")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "22b1a7b9",
   "metadata": {
    "papermill": {
     "duration": 0.0232,
     "end_time": "2025-09-15T06:33:45.342216",
     "exception": false,
     "start_time": "2025-09-15T06:33:45.319016",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "## Final Evaluation and Visualization"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "id": "dd98c663",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2025-09-15T06:33:45.389644Z",
     "iopub.status.busy": "2025-09-15T06:33:45.388789Z",
     "iopub.status.idle": "2025-09-15T06:33:47.641799Z",
     "shell.execute_reply": "2025-09-15T06:33:47.640720Z"
    },
    "papermill": {
     "duration": 2.27844,
     "end_time": "2025-09-15T06:33:47.643343",
     "exception": false,
     "start_time": "2025-09-15T06:33:45.364903",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\u001b[1m9/9\u001b[0m \u001b[32m━━━━━━━━━━━━━━━━━━━━\u001b[0m\u001b[37m\u001b[0m \u001b[1m2s\u001b[0m 217ms/step\n",
      "Final Test RMSE: 56055.1416\n",
      "Final Test MAPE: 0.0343\n",
      "Final Test MSLE: 0.001660\n",
      "Final Test R² Score: 0.8645\n"
     ]
    }
   ],
   "source": [
    "# Prediction\n",
    "y_pred_final = final_model.predict(X_test)\n",
    "y_pred_inv_final = scaler.inverse_transform(np.concatenate((y_pred_final, np.zeros((y_pred_final.shape[0], scaled_features.shape[1]-1))), axis=1))[:,0]\n",
    "y_test_inv_final = scaler.inverse_transform(np.concatenate((y_test.reshape(-1,1), np.zeros((y_test.shape[0], scaled_features.shape[1]-1))), axis=1))[:,0]\n",
    "\n",
    "# Evaluation\n",
    "final_rmse = np.sqrt(mean_squared_error(y_test_inv_final, y_pred_inv_final))\n",
    "final_mape = mean_absolute_percentage_error(y_test_inv_final, y_pred_inv_final)\n",
    "final_r2 = r2_score(y_test_inv_final, y_pred_inv_final)\n",
    "final_msle = mean_squared_log_error(y_test_inv_final, y_pred_inv_final)\n",
    "\n",
    "print(f\"Final Test RMSE: {final_rmse:.4f}\")\n",
    "print(f\"Final Test MAPE: {final_mape:.4f}\")\n",
    "print(f\"Final Test MSLE: {final_msle:.6f}\")\n",
    "print(f\"Final Test R² Score: {final_r2:.4f}\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "id": "2802e9bb",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2025-09-15T06:33:47.767298Z",
     "iopub.status.busy": "2025-09-15T06:33:47.766978Z",
     "iopub.status.idle": "2025-09-15T06:33:48.020898Z",
     "shell.execute_reply": "2025-09-15T06:33:48.019955Z"
    },
    "papermill": {
     "duration": 0.28173,
     "end_time": "2025-09-15T06:33:48.022667",
     "exception": false,
     "start_time": "2025-09-15T06:33:47.740937",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\u001b[1m9/9\u001b[0m \u001b[32m━━━━━━━━━━━━━━━━━━━━\u001b[0m\u001b[37m\u001b[0m \u001b[1m0s\u001b[0m 17ms/step\n",
      "Validation RMSE: 15436.1413\n",
      "Validation MAPE: 0.0119\n",
      "Validation Test MSLE: 0.000227\n",
      "Validation R² Score: 0.9009\n"
     ]
    }
   ],
   "source": [
    "# Evaluation on Validation set\n",
    "y_val_pred = final_model.predict(X_val)\n",
    "\n",
    "# inverse transform\n",
    "y_val_pred_inv = scaler.inverse_transform(\n",
    "    np.concatenate((y_val_pred, np.zeros((y_val_pred.shape[0], scaled_features.shape[1]-1))), axis=1)\n",
    ")[:,0]\n",
    "\n",
    "y_val_inv = scaler.inverse_transform(\n",
    "    np.concatenate((y_val.reshape(-1,1), np.zeros((y_val.shape[0], scaled_features.shape[1]-1))), axis=1)\n",
    ")[:,0]\n",
    "\n",
    "# metrics\n",
    "val_rmse = np.sqrt(mean_squared_error(y_val_inv, y_val_pred_inv))\n",
    "val_mape = mean_absolute_percentage_error(y_val_inv, y_val_pred_inv)\n",
    "val_r2   = r2_score(y_val_inv, y_val_pred_inv)\n",
    "val_msle = mean_squared_log_error(y_val_inv, y_val_pred_inv)\n",
    "\n",
    "print(f\"Validation RMSE: {val_rmse:.4f}\")\n",
    "print(f\"Validation MAPE: {val_mape:.4f}\")\n",
    "print(f\"Validation Test MSLE: {val_msle:.6f}\")\n",
    "print(f\"Validation R² Score: {val_r2:.4f}\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "3c120042",
   "metadata": {
    "papermill": {
     "duration": 0.024643,
     "end_time": "2025-09-15T06:33:48.071842",
     "exception": false,
     "start_time": "2025-09-15T06:33:48.047199",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "## Save the Final Model (.h5 format)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "id": "379ef7a5",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2025-09-15T06:33:48.121576Z",
     "iopub.status.busy": "2025-09-15T06:33:48.121233Z",
     "iopub.status.idle": "2025-09-15T06:33:48.166094Z",
     "shell.execute_reply": "2025-09-15T06:33:48.165104Z"
    },
    "papermill": {
     "duration": 0.071506,
     "end_time": "2025-09-15T06:33:48.167810",
     "exception": false,
     "start_time": "2025-09-15T06:33:48.096304",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Model saved successfully!\n"
     ]
    }
   ],
   "source": [
    "# Save Final Model to .h5 file\n",
    "final_model.save('gold_price_prediction_final.h5')\n",
    "print(\"Model saved successfully!\")"
   ]
  }
 ],
 "metadata": {
  "kaggle": {
   "accelerator": "none",
   "dataSources": [
    {
     "datasetId": 7000808,
     "sourceId": 12588679,
     "sourceType": "datasetVersion"
    }
   ],
   "dockerImageVersionId": 31089,
   "isGpuEnabled": false,
   "isInternetEnabled": true,
   "language": "python",
   "sourceType": "notebook"
  },
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.11.13"
  },
  "papermill": {
   "default_parameters": {},
   "duration": 482.796544,
   "end_time": "2025-09-15T06:33:50.913957",
   "environment_variables": {},
   "exception": null,
   "input_path": "__notebook__.ipynb",
   "output_path": "__notebook__.ipynb",
   "parameters": {},
   "start_time": "2025-09-15T06:25:48.117413",
   "version": "2.6.0"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
